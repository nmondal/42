/* Entity End Point Handling */
def bucket_and_id(){
    entity_urn = req.params("id")
    #(entity_class, entity_id) = entity_urn.split(":")
    assert( entity_class @ _shared["CONFIG"], jstr( {"success" : false, "entity-class is not configured!" } ), 404 )
    [ _shared["CONFIG"][entity_class]["bucket"], entity_id ]
}

def entity_read(){
    #(bucket, entity_id) = bucket_and_id()
    js = _ds.storage.loads( bucket, entity_id ) // this itself should do it
    panic( empty(js), jstr( {"success" : false, "entity does not exist!" } ), 404  )
    js // return
}

def entity_create(){
   entity_class = req.params("class")
   assert( entity_class @ _shared["CONFIG"], jstr( {"success" : false, "entity-class is not configured!" } ), 404 )
   bucket = _shared["CONFIG"][entity_class]["bucket"]
   data = req.attribute("_body") ?? json(req.body)
   entity_id = str( INT(time()) , 62 ) // base 62 encoding
   data.urn = entity_class + ":" + entity_id
   query_template = _shared["CREATE"]
   // this is unreliable
   em = _ds.graph.update( query_template , [ data.urn ] )
   panic( em.inError, jstr( { "status" : false, "message" : em.error().getMessage() } ) , 424 )
   // this is reliable so do it in the end
   _ds.storage.dump( bucket, entity_id , data )
   jstr( { "urn" : data.urn } ) // this is Golden enough
}

def entity_update(){
   #(bucket, entity_id) = bucket_and_id()
   cur_obj = _ds.storage.load( bucket, entity_id )
   panic( empty(cur_obj), jstr( {"success" : false, "entity does not exist!" } ), 404  )
   // Now do the rest
   import org.apache.commons.jxpath.JXPathContext as JX
   ctx = JX.newContext(cur_obj)
   data = req.attribute("_body") ?? json(req.body)
   for ( entry : data.apply.entries ){ ctx.setValue( entry.key, entry.value ) }
   _ds.storage.dump( bucket, entity_id , data )
   jstr( { "urn" : data.urn } ) // TODO get the version revision too
}

switch( req.requestMethod() ){
    case "GET" :  entity_read()
    case "PUT" :  entity_create()
    case "POST" : entity_update()
}
